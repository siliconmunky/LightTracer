////////////////////////////////////////////////////////////////////////////////
// Filename: color.ps
////////////////////////////////////////////////////////////////////////////////

struct tPixel
{
    float4 mColour;
};


Texture2D NoiseTexture : register(t0);
SamplerState NoiseSS : register(s0);

StructuredBuffer<tPixel> ComputeOutputBuffer : register(t1);

cbuffer ResConstantBuffer : register(b0)
{
    int gWidth;
    int gHeight;
};

cbuffer FVConstantBuffer : register(b1)
{
	float gTime;
	float gNoiseOffsetX;
	float gNoiseOffsetY;
};



struct PixelInputType
{
    float4 position : SV_POSITION;
	float2 uv	: TEXCOORD;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 ColorPixelShader(PixelInputType input) : SV_TARGET
{
	float2 uv = input.uv;

	uint index = (int)(uv.x * gWidth) + (int)(uv.y * gHeight) * gWidth;

	float4 result;
	result.rgb = ComputeOutputBuffer[index].mColour.rgb;
	result.a = 1.0;


	float dither = NoiseTexture.Sample(NoiseSS, (uv + float2(gNoiseOffsetX, gNoiseOffsetY)) * 50).r; //50 is a hack to tile many tiles, seems sufficient
	dither = dither / 150.0; //150 is a hack, produces a good enough result
	
	result.rgb += dither;

    return result;
}
